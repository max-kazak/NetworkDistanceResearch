---
title: "Les_miserables"
author: "Max"
date: "Tuesday, April 07, 2015"
output: pdf_document
---
##Load Data

Load libraries  
```{r}
library(igraph)
library(ggplot2)
library(reshape2)

source('metrics.R')
```

Load Les Miserables graph
```{r}
load("miserables.Rdata")
```
Let's view graph nodes and general structure
```{r}
V(miserables)
```
```{r}
plot(miserables)
```

Let's see if we have communities here using the Grivan-Newman algorithm. 
1st we calculate the edge betweenness, merges, etc...
```{r}
ebc <- edge.betweenness.community(miserables, directed=F)
```
Now we have the merges/splits and we need to calculate the modularity
for each merge for this we'll use a function that for each edge
removed will create a second graph, check for its membership and use
that membership to calculate the modularity
```{r}
mods <- sapply(0:ecount(miserables), function(i){
    g <- delete.edges(miserables, ebc$removed.edges[seq(length=i)])
    cl <- clusters(g)$membership
    modularity(miserables,cl)
})
```
We can now plot all modularities
```{r}
plot(mods, pch=20)
```

Save clusterization with max modularity
```{r}
miserables.separated = delete.edges(miserables, ebc$removed.edges[seq(length=which.max(mods)-1)])
miserables.clust = clusters(miserables.separated)$membership
#clusters in df
df.clust = data.frame(V(miserables)$name,miserables.clust)
colnames(df.clust) = c("V","clust")
```

View graph colored by cluster
```{r}
V(miserables)$color = miserables.clust
miserables$layout <- layout.fruchterman.reingold
plot(miserables)
```

##Classification
```{r}
source('classification.R')
```

Let's classify with **logforest** distance with **alpha** parameter **0.01**
```{r}
class = classify.multiple(times = 100, graph = miserables, distance = logforest_dist, alpha = 0.01)
```
And plot miserables graph with classification coloring
```{r}
V(miserables)$color = class
plot(miserables)
```

##Modularity and error alpha-resistance
Let's check resistance of distances in respect to modularity and error rate
```{r}
alphas <- seq(0.01, 0.91, by=0.01)
dist.vect <- c(plainwalk_dist, walk_dist , plainforest_dist, logforest_dist, communicability_dist, logcommunicability_dist)
names(dist.vect) <- c("plain_walk", "walk", "plain_forest", "log_forest", "communicability", "log_communicability")
```

Calculate modularity and error rate for each alpha
```{r, cache=TRUE}
mods.df = data.frame(alpha = alphas)
acc.df = data.frame(alpha = alphas)

for(i in 1:length(dist.vect)) {
    mods = vector()
    acc = vector()
    for(a in alphas) {
        class = classify.multiple(times = 100, graph = miserables, distance = dist.vect[[i]], alpha = a)
        mods = c(mods, modularity(miserables, class))
        acc = c(acc, sum(class==miserables.clust)/length(class))
    }
    mods.df[names(dist.vect[i])] = mods
    acc.df[names(dist.vect[i])] = acc
}
```

View dependency of alpha and modularity
```{r}
mods.melted.df <- melt(mods.df, id=c("alpha"))
g.mods<-ggplot(mods.melted.df) + 
    geom_point(aes(alpha, value, colour=variable)) +
    geom_smooth(aes(alpha, value, colour=variable)) +
    geom_line(aes(alpha, value, colour=variable))
plot(g.mods)
```

View dependency of alpha and error
```{r}
acc.melted.df <- melt(acc.df, id=c("alpha"))
g.acc<-ggplot(acc.melted.df) + 
                 geom_point(aes(alpha, value, colour=variable)) +
                 geom_smooth(aes(alpha, value, colour=variable)) +
                 geom_line(aes(alpha, value, colour=variable))
plot(g.acc)
```
